diff --git a/erts/doc/src/match_spec.xml b/erts/doc/src/match_spec.xml
index 2a14f1e47be..764ac921ddb 100644
--- a/erts/doc/src/match_spec.xml
+++ b/erts/doc/src/match_spec.xml
@@ -11,7 +11,7 @@
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
- 
+
           http://www.apache.org/licenses/LICENSE-2.0
 
       Unless required by applicable law or agreed to in writing, software
@@ -134,6 +134,7 @@
       <item>ActionFunction ::= <c><![CDATA[set_seq_token]]></c> |
         <c><![CDATA[get_seq_token]]></c> | <c><![CDATA[message]]></c> |
         <c><![CDATA[return_trace]]></c> | <c><![CDATA[exception_trace]]></c> |
+        <c><![CDATA[process_backtrace]]></c> |
         <c><![CDATA[process_dump]]></c> | <c><![CDATA[enable_trace]]></c> |
         <c><![CDATA[disable_trace]]></c> | <c><![CDATA[trace]]></c> |
         <c><![CDATA[display]]></c> | <c><![CDATA[caller]]></c> |
@@ -316,7 +317,7 @@
           <p>As a special case, <c><![CDATA[{message, false}]]></c> disables
             sending of trace messages ('call' and 'return_to') for this function
             call, just like if the match specification had not matched.
-            This can be useful if only the side effects of 
+            This can be useful if only the side effects of
             the <c><![CDATA[MatchBody]]></c> part are desired.</p>
           <p>Another special case is <c><![CDATA[{message, true}]]></c>, which
             sets the default behavior, as if the function had no match
@@ -351,6 +352,12 @@
             an <c><![CDATA[exception_from]]></c> trace message is generated,
             regardless of the exception is caught or not.</p>
         </item>
+        <tag><c>process_backtrace:</c></tag>
+        <item>
+          <p>Returns some textual information about the current process's stack
+            as a binary. Takes no arguments and is only allowed in the
+            <c><![CDATA[MatchBody]]></c> part when tracing.</p>
+        </item>
         <tag><c>process_dump</c></tag>
         <item>
           <p>Returns some textual information about
@@ -371,7 +378,7 @@
             process <c><![CDATA[P1]]></c> gets its trace messages sent to the
             same tracer as the process executing the statement uses.
             <c><![CDATA[P1]]></c> <em>cannot</em> be one of the atoms
-            <c><![CDATA[all]]></c>, <c><![CDATA[new]]></c> or 
+            <c><![CDATA[all]]></c>, <c><![CDATA[new]]></c> or
             <c><![CDATA[existing]]></c> (unless they are registered names).
             <c><![CDATA[P2]]></c> <em>cannot</em> be
             <c><![CDATA[cpu_timestamp]]></c> or <c><![CDATA[tracer]]></c>.</p>
@@ -732,7 +739,7 @@
 
     <code type="none"><![CDATA[
 [{['$1', '$2', '$3'],
-  [{'orelse', 
+  [{'orelse',
       {'=:=', '$3', {{'$1','$2'}}},
       {'and', 
         {'=:=', '$1', {hd, '$3'}},
diff --git a/erts/emulator/beam/atom.names b/erts/emulator/beam/atom.names
index 7b12e5432d2..1bad509c529 100644
--- a/erts/emulator/beam/atom.names
+++ b/erts/emulator/beam/atom.names
@@ -532,6 +532,7 @@ atom processes_used
 atom process_count
 atom process_display
 atom process_limit
+atom process_backtrace
 atom process_dump
 atom procs
 atom proc_sig
diff --git a/erts/emulator/beam/erl_db_util.c b/erts/emulator/beam/erl_db_util.c
index 13eacaa8a93..2d117d0fcc2 100644
--- a/erts/emulator/beam/erl_db_util.c
+++ b/erts/emulator/beam/erl_db_util.c
@@ -234,6 +234,7 @@ typedef enum {
     matchSelf,
     matchWaste,
     matchReturn,
+    matchProcessBacktrace,
     matchProcessDump,
     matchDisplay,
     matchIsSeqTrace,
@@ -2452,6 +2453,14 @@ Eterm db_prog_match(Process *c_p,
 	case matchReturn:
 	    ret = *--esp;
 	    break;
+	case matchProcessBacktrace: {
+	    erts_dsprintf_buf_t *dsbufp = erts_create_tmp_dsbuf(0);
+	    erts_stack_dump_abbreviated(ERTS_PRINT_DSBUF, (void *) dsbufp, c_p);
+	    *esp++ = new_binary(build_proc, (byte *)dsbufp->str,
+				dsbufp->str_len);
+	    erts_destroy_tmp_dsbuf(dsbufp);
+	    break;
+	}
 	case matchProcessDump: {
 	    erts_dsprintf_buf_t *dsbufp = erts_create_tmp_dsbuf(0);
             ASSERT(c_p == self);
@@ -4450,6 +4459,36 @@ static DMCRet dmc_display(DMCContext *context,
     return retOk;
 }
 
+static DMCRet dmc_process_backtrace(DMCContext *context,
+                                    DMCHeap *heap,
+                                    DMC_STACK_TYPE(UWord) *text,
+                                    Eterm t,
+                                    int *constant)
+{
+    Eterm *p = tuple_val(t);
+    Uint a = arityval(*p);
+    
+    if (!(context->cflags & DCOMP_TRACE)) {
+	RETURN_ERROR("Special form 'process_backtrace' used in wrong dialect.",
+		     context, 
+		     *constant);
+    }
+    if (context->is_guard) {
+	RETURN_ERROR("Special form 'process_backtrace' called in "
+		     "guard context.", context, *constant);
+    }
+
+    if (a != 1) {
+	RETURN_TERM_ERROR("Special form 'process_backtrace' called with "
+			  "arguments in %T.", t, context, *constant);
+    }
+    *constant = 0;
+    DMC_PUSH(*text, matchProcessBacktrace); /* Creates binary */
+    if (++context->stack_used > context->stack_need)
+	context->stack_need = context->stack_used;
+    return retOk;
+}
+
 static DMCRet dmc_process_dump(DMCContext *context,
 			       DMCHeap *heap,
 			       DMC_STACK_TYPE(UWord) *text,
@@ -4745,6 +4784,8 @@ static DMCRet dmc_fun(DMCContext *context,
 	return dmc_exception_trace(context, heap, text, t, constant);
     case am_display:
 	return dmc_display(context, heap, text, t, constant);
+    case am_process_backtrace:
+	return dmc_process_backtrace(context, heap, text, t, constant);
     case am_process_dump:
 	return dmc_process_dump(context, heap, text, t, constant);
     case am_enable_trace:
@@ -5662,6 +5703,10 @@ void db_match_dis(Binary *bp)
 	    ++t;
 	    erts_printf("Return\n");
 	    break;
+	case matchProcessBacktrace:
+	    ++t;
+	    erts_printf("ProcessBacktrace\n");
+	    break;
 	case matchProcessDump:
 	    ++t;
 	    erts_printf("ProcessDump\n");
diff --git a/erts/emulator/beam/erl_process.c b/erts/emulator/beam/erl_process.c
index be944187550..5694c9b030b 100644
--- a/erts/emulator/beam/erl_process.c
+++ b/erts/emulator/beam/erl_process.c
@@ -609,7 +609,8 @@ do {									\
 
 static void exec_misc_ops(ErtsRunQueue *);
 static void print_function_from_pc(fmtfn_t to, void *to_arg, BeamInstr* x);
-static int stack_element_dump(fmtfn_t to, void *to_arg, Eterm* sp, int yreg);
+static int stack_element_dump(fmtfn_t to, void *to_arg, Process* p, Eterm* sp,
+        int yreg, int abbreviated);
 
 static void aux_work_timeout(void *unused);
 static void aux_work_timeout_early_init(int no_schedulers);
@@ -3431,7 +3432,7 @@ static void check_sleepers_list(ErtsSchedulerSleepList *sl,
         erts_smp_spin_lock(&sl->lock);
 
     ERTS_ASSERT(!find_not || (!find_not->next && !find_not->prev));
-    
+
     last_out = sl->list;
     if (last_out) {
         ErtsSchedulerSleepInfo *tmp = last_out;
@@ -3444,7 +3445,7 @@ static void check_sleepers_list(ErtsSchedulerSleepList *sl,
             if (tmp == find)
                 found = !0;
             tmp = tmp->next;
-            
+
         } while (tmp != last_out);
     }
     ERTS_ASSERT(!find || found);
@@ -3635,7 +3636,7 @@ scheduler_wait(int *fcalls, ErtsSchedulerData *esdp, ErtsRunQueue *rq)
 	    erts_thr_progress_active(esdp, thr_prgr_active = 1);
 	    sched_wall_time_change(esdp, 1);
         }
-        
+
 #ifdef ERTS_DIRTY_SCHEDULERS
         if (ERTS_RUNQ_IX_IS_DIRTY(rq->ix)) {
             erts_smp_spin_lock(&rq->sleepers.lock);
@@ -3659,7 +3660,7 @@ scheduler_wait(int *fcalls, ErtsSchedulerData *esdp, ErtsRunQueue *rq)
             erts_smp_spin_unlock(&rq->sleepers.lock);
         }
 #endif
-        
+
 	erts_smp_runq_lock(rq);
 	sched_active(esdp->no, rq);
 
@@ -6470,7 +6471,7 @@ erts_init_scheduling(int no_schedulers, int no_schedulers_online
 	    erts_alloc_permanent_cache_aligned(
 		ERTS_ALC_T_SCHDLR_DATA,
 		dirty_scheds * sizeof(ErtsAlignedDirtyShadowProcess));
-						   
+
 	erts_aligned_dirty_cpu_scheduler_data =
 	    erts_alloc_permanent_cache_aligned(
 		ERTS_ALC_T_SCHDLR_DATA,
@@ -7782,7 +7783,7 @@ msb_scheduler_type_switch(ErtsSchedType sched_type,
 
         /*
          * Make sure to alternate between dirty types
-         * inbetween normal execution if highest 
+         * inbetween normal execution if highest
          * priorities are equal.
          */
 
@@ -7960,7 +7961,7 @@ suspend_scheduler(ErtsSchedulerData *esdp)
     if (sched_type != ERTS_SCHED_NORMAL)
         ERTS_HDBG_CHK_SLEEP_LIST(&esdp->run_queue->sleepers, !0, NULL, ssi);
 #endif
-    
+
     if (erts_smp_atomic32_read_nob(&ssi->flags) & ERTS_SSI_FLG_MSB_EXEC) {
         ASSERT(no == 1);
         if (!msb_scheduler_type_switch(sched_type, esdp, no))
@@ -9428,7 +9429,7 @@ pid2proc_not_running(Process *c_p, ErtsProcLocks c_p_locks,
     }
 
  done:
-	
+
     if (rp && rp != ERTS_PROC_LOCK_BUSY && !(pid_locks & ERTS_PROC_LOCK_STATUS))
 	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_STATUS);
     if (unlock_c_p_status)
@@ -10919,7 +10920,7 @@ Process *erts_schedule(ErtsSchedulerData *esdp, Process *p, int calls)
 		   ? (state & (ERTS_PSFLG_DIRTY_CPU_PROC
 			       | ERTS_PSFLG_DIRTY_ACTIVE_SYS))
 		   : (rq == ERTS_DIRTY_IO_RUNQ
-		      && (state & ERTS_PSFLG_DIRTY_IO_PROC)));	    
+		      && (state & ERTS_PSFLG_DIRTY_IO_PROC)));
 	}
 #endif
 
@@ -11022,7 +11023,7 @@ Process *erts_schedule(ErtsSchedulerData *esdp, Process *p, int calls)
 	}
 
 	p->fcalls = reds;
-	    
+
 	ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(p);
 
 	/* Never run a suspended process */
@@ -11542,7 +11543,7 @@ erts_execute_dirty_system_task(Process *c_p)
 
     stasks = c_p->dirty_sys_tasks;
     c_p->dirty_sys_tasks = NULL;
-    
+
     while (stasks) {
 	Eterm st_res;
 	ErtsProcSysTask *st = stasks;
@@ -11600,7 +11601,7 @@ dispatch_system_task(Process *c_p, erts_aint_t fail_state,
 	ERTS_INTERNAL_ERROR("Non-dispatchable system task");
 	break;
     }
-	
+
     ERTS_BIF_PREP_RET(ret, am_ok);
 
     /*
@@ -13430,7 +13431,7 @@ send_exit_signal(Process *c_p,		/* current process if and only
 		if (need_locks
 		    && erts_smp_proc_trylock(rp, need_locks) == EBUSY) {
 		    /* ... but we havn't got all locks on it ... */
-		    save_pending_exiter(rp, NULL); 
+		    save_pending_exiter(rp, NULL);
 		    /*
 		     * The pending exit will be discovered when next
 		     * process is scheduled in
@@ -13466,7 +13467,7 @@ send_exit_signal(Process *c_p,		/* current process if and only
 		set_proc_exiting(rp, state, rsn_cpy, bp);
 	    }
 	    else { /* Process running... */
- 
+
 		/*
 		 * The pending exit will be discovered when the process
 		 * is scheduled out if not discovered earlier.
@@ -13688,7 +13689,7 @@ static void doit_exit_monitor(ErtsMonitor *mon, void *vpcontext)
 	    /* else: demonitor while we exited, i.e. do nothing... */
 	    erts_smp_proc_unlock(rp, rp_locks);
 	} else { /* external by pid or name */
-	    ASSERT(is_external_pid(mon->u.pid));    
+	    ASSERT(is_external_pid(mon->u.pid));
 	    dep = external_pid_dist_entry(mon->u.pid);
 	    ASSERT(dep != NULL);
 	    if (dep) {
@@ -13875,7 +13876,7 @@ erts_do_exit_process(Process* p, Eterm reason)
 {
     p->arity = 0;		/* No live registers */
     p->fvalue = reason;
-    
+
 
 #ifdef USE_VM_PROBES
     if (DTRACE_ENABLED(process_exit)) {
@@ -14246,8 +14247,22 @@ erts_continue_exit_process(Process *p)
  * Stack dump functions follow.
  */
 
+void erts_stack_dump2(fmtfn_t to, void *to_arg, Process *p, int abbreviated);
+
 void
 erts_stack_dump(fmtfn_t to, void *to_arg, Process *p)
+{
+    erts_stack_dump2(to, to_arg, p, 0);
+}
+
+void
+erts_stack_dump_abbreviated(fmtfn_t to, void *to_arg, Process *p)
+{
+    erts_stack_dump2(to, to_arg, p, 1);
+}
+
+void
+erts_stack_dump2(fmtfn_t to, void *to_arg, Process *p, int abbreviated)
 {
     Eterm* sp;
     int yreg = -1;
@@ -14257,7 +14272,7 @@ erts_stack_dump(fmtfn_t to, void *to_arg, Process *p)
     }
     erts_program_counter_info(to, to_arg, p);
     for (sp = p->stop; sp < STACK_START(p); sp++) {
-        yreg = stack_element_dump(to, to_arg, sp, yreg);
+        yreg = stack_element_dump(to, to_arg, p, sp, yreg, abbreviated);
     }
 }
 
@@ -14315,16 +14330,19 @@ print_function_from_pc(fmtfn_t to, void *to_arg, BeamInstr* x)
 }
 
 static int
-stack_element_dump(fmtfn_t to, void *to_arg, Eterm* sp, int yreg)
+stack_element_dump(fmtfn_t to, void *to_arg, Process *p, Eterm* sp, int yreg, int abbreviated)
 {
     Eterm x = *sp;
 
     if (yreg < 0 || is_CP(x)) {
         erts_print(to, to_arg, "\n%p ", sp);
     } else {
-        char sbuf[16];
-        erts_snprintf(sbuf, sizeof(sbuf), "y(%d)", yreg);
-        erts_print(to, to_arg, "%-8s ", sbuf);
+        if (! abbreviated) {
+            /* GOOFUSgoofus */
+            char sbuf[16];
+            erts_snprintf(sbuf, sizeof(sbuf), "y(%d)", yreg);
+            erts_print(to, to_arg, "%-8s ", sbuf);
+        }
         yreg++;
     }
 
@@ -14333,11 +14351,12 @@ stack_element_dump(fmtfn_t to, void *to_arg, Eterm* sp, int yreg)
         print_function_from_pc(to, to_arg, cp_val(x));
         erts_print(to, to_arg, ")\n");
         yreg = 0;
-    } else if is_catch(x) {
+    } else if (! abbreviated && is_catch(x)) {
         erts_print(to, to_arg, "Catch %p (", catch_pc(x));
         print_function_from_pc(to, to_arg, catch_pc(x));
         erts_print(to, to_arg, ")\n");
-    } else {
+    } else if (!abbreviated) {
+        /* GOOFUSgoofus */
 	erts_print(to, to_arg, "%T\n", x);
     }
     return yreg;
diff --git a/erts/emulator/beam/erl_process.h b/erts/emulator/beam/erl_process.h
index b3385b780f6..940b2f55238 100644
--- a/erts/emulator/beam/erl_process.h
+++ b/erts/emulator/beam/erl_process.h
@@ -1866,6 +1866,7 @@ void erts_cleanup_empty_process(Process* p);
 void erts_debug_verify_clean_empty_process(Process* p);
 #endif
 void erts_stack_dump(fmtfn_t to, void *to_arg, Process *);
+void erts_stack_dump_abbreviated(fmtfn_t to, void *to_arg, Process *);
 void erts_limited_stack_trace(fmtfn_t to, void *to_arg, Process *);
 void erts_program_counter_info(fmtfn_t to, void *to_arg, Process *);
 void erts_print_scheduler_info(fmtfn_t to, void *to_arg, ErtsSchedulerData *esdp);
diff --git a/lib/observer/src/observer_trace_wx.erl b/lib/observer/src/observer_trace_wx.erl
index 2c3b46a3a1e..7595e15f705 100644
--- a/lib/observer/src/observer_trace_wx.erl
+++ b/lib/observer/src/observer_trace_wx.erl
@@ -154,6 +154,8 @@ get_default_matchspecs(funcs) ->
       "fun(_) -> exception_trace() end"},
      {"Message Caller", [{'_', [], [{message,{caller}}]}],
       "fun(_) -> message(caller()) end"},
+     {"Message Backtrace", [{'_', [], [{message,{process_backtrace}}]}],
+      "fun(_) -> message(process_backtrace()) end"},
      {"Message Dump", [{'_', [], [{message,{process_dump}}]}],
       "fun(_) -> message(process_dump()) end"}];
 get_default_matchspecs(send) ->
diff --git a/lib/stdlib/src/ms_transform.erl b/lib/stdlib/src/ms_transform.erl
index 6616e957c02..ccdf6314385 100644
--- a/lib/stdlib/src/ms_transform.erl
+++ b/lib/stdlib/src/ms_transform.erl
@@ -961,6 +961,7 @@ action_function(get_seq_token,0) -> true;
 action_function(message,1) -> true;
 action_function(return_trace,0) -> true;
 action_function(exception_trace,0) -> true;
+action_function(process_backtrace,0) -> true;
 action_function(process_dump,0) -> true;
 action_function(enable_trace,1) -> true;
 action_function(enable_trace,2) -> true;
diff --git a/lib/stdlib/test/ms_transform_SUITE.erl b/lib/stdlib/test/ms_transform_SUITE.erl
index d1e6faf8631..689b0e944cd 100644
--- a/lib/stdlib/test/ms_transform_SUITE.erl
+++ b/lib/stdlib/test/ms_transform_SUITE.erl
@@ -731,6 +731,19 @@ action_function(Config) when is_list(Config) ->
 	    "message(X), "
 	    "return_trace(), "
 	    "exception_trace() end)">>),
+    [{['$1','$2'],[],
+	    [{process_backtrace},
+	     {enable_trace,send},
+	     {enable_trace,'$2',send},
+	     {disable_trace,procs},
+	     {disable_trace,'$2',procs}]}] =
+	compile_and_run
+	  (<<"dbg:fun2ms(fun([X,Y]) -> "
+	    "process_backtrace(), "
+	    "enable_trace(send), "
+	    "enable_trace(Y, send), "
+	    "disable_trace(procs), "
+	    "disable_trace(Y, procs) end)">>),
     [{['$1','$2'],[],
 	    [{process_dump},
 	     {enable_trace,send},


